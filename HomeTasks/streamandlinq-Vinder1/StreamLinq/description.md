## Linq

1. GroupByPeriod
   `public IEnumerable<IGrouping<ActivityPeriod, Animal>> GroupByPeriod()`
   Возвращает IEnumerable множеств животных. Каждое множество объединяет животных с одинаковым периодом активности.

2. All
   `public bool All(ActivityPeriod period)`
   Возвращает True, если все животные активны в тот же период, что и в параметре

3. Contains
   `public bool Contains(string name)`
   Возвращает True, если в коллекции есть животное с этим названием

4. OrderByNameAndPeriod
   `public IEnumerable<Animal> OrderByNameAndPeriod()`
   Возвращает всех животных в следующем порядке:
- Сначала дневные, потом ночные
- Внутри вышеописанных групп животные сортируются по названию

## Streams

В Wilderness добавлены 3 метода:

- `void SaveToJson(string path)` - сохраняет данные в формате JSON по указанному адресу
- `void LoadFromJson(string path)` - загружает данные в формате JSON
- `void SaveToYaml(string path)` - сохраняет в YAML

Примечания:

- Я нигде не занимался проверками корректности указанного в аргументе пути, посчитал это излишним.
- При сохранении данных (что в JSON, что в YAML) путём проб и ошибок было выяснено, что интерфейс IEnumerable переопределяет логику сохранения: объект сохраняется не в стандартном для классов виде, а в виде массива элементов, полученных при итерации. Сериализатор видит, что это - IEnumerable, и, бессовестно нарушая третий принцип SOLID, без предупреждения начинает итерироваться по такому объекту, выписывает всё в массив и, довольный, сохраняет данные именно в виде массива, не учитывая, что обратно из массива в изначальный вид данные преобразовать уже не факт, что получится (у меня, с моей реализацией, точно не получится, так как теряются данные свойства CurrentPeriod).
  В связи с этим было решено прибегнуть к костылю - не пытаться сериализовать Wilderness, а создать record WildernessContainer, у которого таких проблем не будет, и при сериализации\десериализации преобразовывать данные к этому типу и работать уже с ним.