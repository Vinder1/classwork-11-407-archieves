
# SOLID (четвертое дз по ООП)

**Выполнил:** Галиуллин Карим, 11-407      
**Тема**: Электрогенераторы


# Несоответствия
1. **S: Single Responsibility Principle**: Класс FuelGenerator с одной стороны выполняет всего одну функцию - реализует метод Generate(). С другой стороны, в рамках одной задачи он реализует два метода - TurnFuelIntoEnergy() и DisposeWaste(). Получается, что эти методы сильно связаны друг с другом.
   Плохо это или нет? С одной стороны да, так как сильная связанность это плохо. С другой стороны нет, так как по идее реализация утилизации отходов все равно полностью зависит от метода выработки энергии - мы же должны знать, что мы утилизируем и надо ли оно, перед тем как думать, как мы будем это делать.
   Будем считать, что это всё таки плохо.

2. **O: Open-Closed Principle**: Несоответствий не найдено.
3. **L: Liskov Substitution Principle**: Класс FuelGenerator требует регулярно вызывать AddFuel для эффективной работы, что выделяет генераторы такого типа и требует особой проверки.
4. **I: Interface Segregation Principle**: Несоответствий нет, так как тут всего один интерфейс, в котором всего один метод.
5. **D: Dependency Inversion Principle**: Несоответствий нет, так как в коде нигде абстракция не зависит от реализации (кроме уже упомянутого момента с FuelGenerator, который требует подкидывать топливо)

# Решения
1. Проблема со связностью двух методов в FuelGenerator
> **Стараемся где можно уйти от наследования к композиции**

Выносим реализацию этих методов в отдельные классы. Убиваем сразу двух зайцев - во-первых, теперь FuelGenerator не ответственен за реализацию этих методов, только за их вызов в правильном порядке. Во-вторых, мы реализуем один из подходов DI.

2. Проблема специфики FuelGenerator

Полностью эту проблему решить не получится никак, так как IEnergyGenerator не подразумевает регулярное обслуживание, а топливный генератор в нём нуждается. Тут два варианта: либо вносим метод обслуживания в интерфейс IEnergyGenerate (что нехорошо с точки зрения Принципа разделения интерфейса), либо создаём отдельный интерфейс IMaintainable и превращаем проверку на FuelGenerator в проверку на IMaintainable. Это неполное решение проблемы, но лучше чем ничего.